<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-05T09:53:29.781Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue组件之间的通信</title>
    <link href="http://example.com/2023/03/05/vueCommunication/"/>
    <id>http://example.com/2023/03/05/vueCommunication/</id>
    <published>2023-03-05T09:43:40.369Z</published>
    <updated>2023-03-05T09:53:29.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue组件之间的通信"><a href="#vue组件之间的通信" class="headerlink" title="vue组件之间的通信"></a>vue组件之间的通信</h1><h2 id="一、组件间通信的概念"><a href="#一、组件间通信的概念" class="headerlink" title="一、组件间通信的概念"></a>一、组件间通信的概念</h2><p>指组件( .vue )通过某种方式来传递信息以达到某个目的。举个例子：我们在使用 UI 框架中的 table 组件，可能会往 table 组件中传入某些数据，这个本质就形成了组件之间的通信。</p><h2 id="二、组件通信的作用"><a href="#二、组件通信的作用" class="headerlink" title="二、组件通信的作用"></a>二、组件通信的作用</h2><p>在vue中，每个组件之间都有独自的作用域，组件间的数据是无法共享的。但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统。</p><h2 id="三、Vue-组件如何进行传值的"><a href="#三、Vue-组件如何进行传值的" class="headerlink" title="三、Vue 组件如何进行传值的"></a>三、Vue 组件如何进行传值的</h2><h3 id="1-父子组件通信"><a href="#1-父子组件通信" class="headerlink" title="1. 父子组件通信"></a>1. 父子组件通信</h3><p>1.1 父组件向子组件传递数据</p><ul><li>父组件通过 <code>自定义属性名=&quot;需要传递的数据&quot;</code>，子组件通过 <code>props</code> 接收</li></ul><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Father.vue 组件</span></span><br><span class="line">&lt;<span class="title class_">Children</span> <span class="attr">name</span>:<span class="string">&quot;yang&quot;</span> age=<span class="number">18</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Children.vue 组件</span></span><br><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="title class_">String</span></span><br><span class="line"><span class="attr">age</span>:&#123;</span><br><span class="line"><span class="attr">type</span>:<span class="title class_">Number</span>,</span><br><span class="line"><span class="attr">defaule</span>:<span class="number">18</span>,</span><br><span class="line"><span class="attr">require</span>:<span class="literal">true</span> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>父组件通过 <code>v-model</code> 传递需要的参数，子组件 <code>props</code> 中通过 <code>value</code> 接收（适用于基本数据类型）</li><li>父组件通过 <code>自定义属性名.sync=&quot;需要传递的数据&quot;</code>，子组件通过 <code>props</code> 接收（适用于基本数据类型）</li></ul><p>1.2 子组件向父组件传递数据</p><ul><li>子组件通过 <code>$emit(&#39;自定义事件名&#39;， 传递的参数)</code>，父组件 <code>@自定义事件名=&quot;绑定的自定义方法($event)&quot;</code></li></ul><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Father.vue 组件</span></span><br><span class="line">&lt;<span class="title class_">Children</span> @add=<span class="string">&quot;numAdd($event)&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Children.vue 组件</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;add&#x27;</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure></div><ul><li>子组件可直接通过 <code>$emit(&#39;input&#39;， 需要改变的值)</code>（适用于基本数据类型）</li><li>子组件可直接通过 <code>$emit(&#39;update:自定义属性名&#39;， 需要改变的值)</code>（适用于基本数据类型）</li></ul><p>1.3 其他方法</p><ul><li>ref &#x2F; $refs：<br>父组件通过 <code>$refs</code> 可直接调用子组件的数据和方法<br>可读不可改</li></ul><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Father.vue 组件</span></span><br><span class="line">&lt;<span class="title class_">Children</span> ref=<span class="string">&quot;foo&quot;</span> /&gt;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">foo</span></span><br></pre></td></tr></table></figure></div><ul><li>$parent &#x2F; $children：<br>使用 <code>$parent</code> 访问父组件实例，<code>$children</code> 访问子组件实例<br><strong>注意：</strong>$children拿到的是所有组件的实例，是一个数组，且是无序的</li></ul><p>1.4 适用于父子传参 及 祖先后代传参</p><ul><li>依赖注入 - provide&#x2F;inject：<br>父组件使用 <code>provide</code> 来传参，所有子组件都可以获取到，需要参数的子组件通过 <code>inject</code> 来接收（可读不可改）</li></ul><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 祖先组件</span></span><br><span class="line"><span class="title function_">provide</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">foo</span>:<span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后代组件</span></span><br><span class="line"><span class="attr">inject</span>:[<span class="string">&#x27;foo&#x27;</span>]</span><br></pre></td></tr></table></figure></div><ul><li>$attrs 和 $listeners（可以批量传数据或方法）<br> <code>$attrs</code> 不包括 <code>props</code> 传递的属性，<code>$listeners</code> 包括了所有作用在这个组件上的监听器</li></ul><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Father.vue 组件</span></span><br><span class="line">&lt;<span class="title class_">Child</span> name=<span class="string">&quot;yang&quot;</span> @test=<span class="string">&quot;test&quot;</span>&gt;&lt;/<span class="title class_">Child</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.vue 组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Grandson</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Grandson</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在祖先组件中使用</span></span><br><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$attrs</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="2-兄弟组件通信"><a href="#2-兄弟组件通信" class="headerlink" title="2. 兄弟组件通信"></a>2. 兄弟组件通信</h3><p>eventBus事件总线：<br>创建一个中央事件总线 <code>EventBus</code>，兄弟组件通过 <code>$emit</code> 触发自定义事件，<code>$emit</code> 第二个参数为传递的数 值，另一个兄弟组件通过 <code>$on</code> 监听自定义事件</p><h3 id="3-无直接关系组件通信"><a href="#3-无直接关系组件通信" class="headerlink" title="3. 无直接关系组件通信"></a>3. 无直接关系组件通信</h3><p>Vuex</p><p>vuex相当于一个存储共享变量的容器</p><ul><li>state：存放共享变量</li><li>mutations：存放修改state的方法</li><li>actions：存放异步方法，在mutations的基础上进行</li><li>getters：相当于计算属性，用来获得共享变量的值</li><li>modules：将项目中的各个模块分开定义和操作</li></ul><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><ul><li>父子关系的组件数据传递选择 props 与 $emit 进行传递，也可选择 ref</li><li>兄弟关系的组件数据传递可选择 $bus ，其次可以选择 $parent 进行传递</li><li>祖先与后代组件数据传递可选择 attrs 与 listeners 或者 Provide 与 Inject</li><li>复杂关系的组件数据传递可以通过 vuex 存放共享的变量</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue组件之间的通信&quot;&gt;&lt;a href=&quot;#vue组件之间的通信&quot; class=&quot;headerlink&quot; title=&quot;vue组件之间的通信&quot;&gt;&lt;/a&gt;vue组件之间的通信&lt;/h1&gt;&lt;h2 id=&quot;一、组件间通信的概念&quot;&gt;&lt;a href=&quot;#一、组件间通信的概念&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue指令</title>
    <link href="http://example.com/2023/02/11/vueInstruct/"/>
    <id>http://example.com/2023/02/11/vueInstruct/</id>
    <published>2023-02-11T12:50:02.145Z</published>
    <updated>2022-12-03T06:41:18.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h1><h2 id="一、v-bind-动态属性"><a href="#一、v-bind-动态属性" class="headerlink" title="一、v-bind 动态属性"></a>一、v-bind 动态属性</h2><ol><li><strong>作用：</strong>给标签属性设置vue变量的值</li><li><strong>语法：</strong><code>v-bind:属性名=&quot;vue变量&quot;</code></li><li><strong>简写：</strong><code>:属性名=&quot;vue变量&quot;</code></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-bind:src=&quot;imgSrc&quot;&gt;</span><br><span class="line">&lt;img :src=&quot;imgSrc&quot;&gt;</span><br></pre></td></tr></table></figure></div><p>v-bind动态属性作用于图片时尤其需要注意，v-bind 会直接将资源路径认定为字符串，解决方法为：直接在v-bind动态属性后面传递实际的资源。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">     &lt;img v-bind:src=&quot;imgUrl1&quot; alt=&quot;&quot;&gt;</span><br><span class="line">     &lt;img :src=&quot;imgUrl2&quot; alt=&quot;&quot;&gt;</span><br><span class="line">     &lt;img :src=&quot;imgUrl3&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 通过import引入资源文件，在data中进行定义，最后再动态属性中使用</span><br><span class="line">import img from &#x27;../assets/gqwytx.jpg&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;Picture&#x27;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            imgUrl1:&quot;../assets/gqwytx.jpg&quot;,</span><br><span class="line">            imgUrl2: img,</span><br><span class="line">            // require 引入资源文件，直接在动态属性中使用</span><br><span class="line">            // 优势：require引入资源的方式是按需的，这样一来，页面初始更新效率会更高</span><br><span class="line">            imgUrl3: require(&#x27;../assets/gqwytx.jpg&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div><h2 id="二、v-on-事件绑定"><a href="#二、v-on-事件绑定" class="headerlink" title="二、v-on 事件绑定"></a>二、<strong><strong>v-on 事件绑定</strong></strong></h2><ol><li><strong>作用：</strong>给标签绑定事件</li><li><strong>语法：</strong><ul><li>v-on:事件名&#x3D;”methods中的函数”</li><li>v-on:事件名&#x3D;”methods中的函数(实参)”</li><li>v-on:事件名&#x3D;”少量代码”  <strong>(不推荐)</strong></li></ul></li><li><strong>简写：</strong>@事件名&#x3D;”methods中的函数(实参)”</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   &lt;button v-on:click=&quot;addFn&quot;&gt;点我+1&lt;/button&gt;              // v-on:事件名=&quot;methods中的函数&quot;</span><br><span class="line">   &lt;button v-on:click=&quot;addCountFn(2)&quot;&gt;点我+2&lt;/button&gt;      // v-on:事件名=&quot;methods中的函数(实参)&quot;</span><br><span class="line">&lt;button v-on:click=&quot;count = count + 1&quot;&gt;点我+1&lt;/button&gt;  // v-on:事件名=&quot;少量代码&quot;    </span><br><span class="line">&lt;button @click=&quot;subFn()&quot;&gt;点我减少1&lt;/button&gt;             // @事件名=&quot;methods中的函数(实参)&quot;</span><br></pre></td></tr></table></figure></div><h2 id="三、v-on-获取事件对象"><a href="#三、v-on-获取事件对象" class="headerlink" title="三、v-on 获取事件对象"></a>三、v-on 获取事件对象</h2><ol><li><strong>作用：</strong>vue事件处理函数中, 拿到事件对象</li><li><strong>语法：</strong><ul><li>如果没有传参，则通过形参直接接收，在定义方法时默认的事件对象在第一个形参上。</li><li>如果传参，则通过<code>$event</code>指代事件对象传给事件处理函数，使用时，对应实参位置设置新参即可使用。</li></ul></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a @click=&quot;goUrl&quot; href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;</span><br><span class="line">&lt;a @click=&quot;goUrl($event)&quot; href=&quot;http://www.taobao.com&quot;&gt;淘宝&lt;/a&gt;</span><br></pre></td></tr></table></figure></div><p><strong>只要在使用方法时打上小括号，就会覆盖原本vue默认设置在第一个形参上的事件对象参数。</strong></p><h2 id="四、v-on-修饰符"><a href="#四、v-on-修饰符" class="headerlink" title="四、v-on 修饰符"></a>四、<strong><strong>v-on 修饰符</strong></strong></h2><ol><li><strong>语法：</strong>@事件名.修饰符&#x3D;”methods里函数”<ul><li>.stop - 阻止事件冒泡</li><li>.prevent - 阻止默认行为</li><li>.once - 程序运行期间, 只触发一次事件处理函数</li></ul></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;fatherFn&quot;&gt;</span><br><span class="line">    &lt;button @click.stop=&quot;oneFn&quot;&gt;阻止事件冒泡&lt;/button&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.stop&gt;去百度&lt;/a&gt;</span><br><span class="line">    &lt;button @click.once=&quot;twoFn&quot;&gt;事件处理函数触发一次&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></div><h2 id="五、v-on-按键修饰符"><a href="#五、v-on-按键修饰符" class="headerlink" title="五、v-on 按键修饰符"></a>五、v-on 按键修饰符</h2><ol><li><strong>作用：</strong>给键盘事件, 添加修饰符</li><li><strong>语法：</strong><ul><li>@keyup.enter  -  监测回车按键，按下回车触发绑定</li><li>@keyup.esc - 监测返回按键，按下返回触发绑定</li></ul></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- .enter-回车 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; @keydown.enter=&quot;enterFn&quot;&gt;</span><br><span class="line">&lt;!-- .esc修饰符 - 取消键 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; @keyup.esc=&quot;escFn&quot;&gt;</span><br></pre></td></tr></table></figure></div><h2 id="六、v-model"><a href="#六、v-model" class="headerlink" title="六、v-model"></a>六、v-model</h2><ol><li><p><strong>作用：</strong>把value属性和vue数据变量, 双向绑定到一起</p><pre><code>        **当数据改变时，视图自动同步；当视图改变时，数据自动同步。**</code></pre></li><li><p><strong>语法：</strong>v-model&#x3D;”vue数据变量”</p></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; value=&quot;男&quot; v-model=&quot;sex&quot; /&gt; 男</span><br><span class="line">   &lt;input type=&quot;radio&quot; value=&quot;女&quot; v-model=&quot;sex&quot; /&gt; 女</span><br></pre></td></tr></table></figure></div><h3 id="6-1-v-model-的修饰符"><a href="#6-1-v-model-的修饰符" class="headerlink" title="6.1 v-model 的修饰符"></a>6.1 <strong><strong>v-model 的修饰符</strong></strong></h3><ol><li><strong>语法：</strong>v-model.修饰符&#x3D;”vue数据变量”<ul><li>.number - 将输入框中的值以 parseFloat 的形式转化为数字类型 (常用)，会自动清除后续非数字部分，如果第一个字符就不是数字时，.number修饰符就失效了。</li><li>.trim - 去除收尾空格字符 (常用)。</li><li>.lazy - 将 input 输入时触发的实时更新数据操作转移到失焦、回车时触发。</li></ul></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 转化数字 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model.number=&quot;newNumber&quot; /&gt;</span><br><span class="line">&lt;!-- 取消前后空格 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model.trim=&quot;newTrim&quot; /&gt;</span><br><span class="line">&lt;!-- 懒更新 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model.lazy=&quot;newLazy&quot; /&gt;</span><br></pre></td></tr></table></figure></div><h2 id="七、v-text-和-v-html"><a href="#七、v-text-和-v-html" class="headerlink" title="七、v-text 和 v-html"></a>七、<strong><strong>v-text 和 v-html</strong></strong></h2><ol><li><strong>作用：</strong>更新DOM对象的 innerText &#x2F; innerHTML</li><li><strong>语法：</strong><ul><li>v-text&#x3D;”vue数据变量”</li><li>v-html&#x3D;”vue数据变量”</li></ul></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-text=&quot;str&quot;&gt;&lt;/p&gt;</span><br><span class="line">   &lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></div><p>v-text 使用时不允许当前标签内有任何子元素，因为本来当前元素中的内容就会被v-text中的内容覆盖，所以当前标签中的子元素显得毫无意义甚至影响页面的渲染效率。</p><h2 id="八、v-show-和-v-if"><a href="#八、v-show-和-v-if" class="headerlink" title="八、v-show 和 v-if"></a>八、<strong><strong>v-show 和 v-if</strong></strong></h2><ol><li><p><strong>作用：</strong>控制标签的显示和隐藏</p></li><li><p><strong>语法：</strong></p><ul><li><p>v-show&#x3D;”vue变量” - 给当前标签设置一个display: none; 来进行隐藏操</p><p>  作，原来的这个标签元素还存在于dom数中。</p></li><li><p>v-if&#x3D;”vue变量” - 直接将需要隐藏的元素从dom树中删除。</p></li></ul></li><li><p><strong>使用场景：</strong>选择v-show和v-if的直接条件：如果当前元素及内部子元素全是静态</p><pre><code>                数据，那么使用v-show，除此以外全用v-if。</code></pre></li></ol><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;flag1&quot;</span>&gt;</span>v-show<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;flag1&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;flag2 === 0&quot;</span>&gt;</span>显示为0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;flag2 === 1&quot;</span>&gt;</span>显示为1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>显示为其他<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="attr">name</span>: <span class="string">&quot;Display&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                   <span class="attr">flag1</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                   <span class="attr">msg</span>: <span class="string">&quot;动态&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                   <span class="attr">flag2</span>: <span class="number">3</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div><h2 id="九、v-for"><a href="#九、v-for" class="headerlink" title="九、v-for"></a>九、<strong><strong>v-for</strong></strong></h2><ol><li><strong>作用：</strong>渲染列表数据时，直接在标签结构中进行数组遍历</li><li><strong>语法：</strong><ul><li>v-for&#x3D;”(值, 索引) in 目标结构”</li><li>v-for&#x3D;”值 in 目标结构”</li></ul></li><li><strong>目标结构：</strong>数组 &#x2F; 对象 &#x2F; 数字 &#x2F; 字符串 (可遍历结构)</li></ol><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 1. 循环简单数组 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, index) in arr&quot;</span> <span class="attr">:key</span> =<span class="string">&quot;index&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2. 循环复杂数组 =&gt; 数组对象 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;value in arr2&quot;</span> <span class="attr">:key</span> =<span class="string">&quot;value.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;&#123; value.name &#125;&#125; ----- &#123;&#123; value.age &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 3. 循环对象 =&gt; 循环的就是对象的属性名和属性值</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        参数1：属性值</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        参数2：属性名</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key) in obj&quot;</span> <span class="attr">:key</span> =<span class="string">&quot;key&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;&#123; value &#125;&#125; ----- &#123;&#123; key &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 4. 循环数字</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        参数1： 从1开始计数到最后的自然数</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        参数2： 下标索引从0开始计数</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, index) in 10&quot;</span> <span class="attr">:key</span> =<span class="string">&quot;index&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 5. 循环字符串</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        参数1：字符串的每一个字符</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        参数2：字符串所在的下标索引，从0开始计数</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, index) in abcdefg&quot;</span> <span class="attr">:key</span> =<span class="string">&quot;index&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&quot;Circulation&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">arr2</span>: [</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#123; <span class="attr">name</span>: <span class="string">&#x27;Lisa&#x27;</span>, <span class="attr">age</span>: <span class="number">7</span>, <span class="attr">id</span>: <span class="number">1</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#123; <span class="attr">name</span>: <span class="string">&#x27;Betty&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">id</span>: <span class="number">2</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      ],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">obj</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>: <span class="string">&#x27;Betty&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">age</span>: <span class="number">21</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">sex</span>: <span class="string">&#x27;female&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue指令&quot;&gt;&lt;a href=&quot;#vue指令&quot; class=&quot;headerlink&quot; title=&quot;vue指令&quot;&gt;&lt;/a&gt;vue指令&lt;/h1&gt;&lt;h2 id=&quot;一、v-bind-动态属性&quot;&gt;&lt;a href=&quot;#一、v-bind-动态属性&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>事件循环(Event Loop)</title>
    <link href="http://example.com/2023/02/11/Event%20Loop/"/>
    <id>http://example.com/2023/02/11/Event%20Loop/</id>
    <published>2023-02-11T12:50:02.043Z</published>
    <updated>2023-03-05T09:17:28.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h1><h2 id="一、什么是Event-Loop"><a href="#一、什么是Event-Loop" class="headerlink" title="一、什么是Event Loop"></a>一、什么是<strong><strong>Event Loop</strong></strong></h2><p>JavaScript是一门单线程语言，它一个时间只能做一件事；</p><p>在js代码运行的时候，会形成一个执行栈，每调用一个函数，就会把该函数的执行上下文放入执行栈；</p><p>另外还有任务队列存放待完成的任务，在js中，有同步任务和异步任务，异步任务又分为宏任务和微任务；</p><p>因为script代码整体就是一个宏任务，因此事件循环先从一个宏任务开始，当执行完宏任务后，就从微任务队列拿微任务到执行栈中执行，当前微任务队列所有微任务执行完后，就执行宏任务队列的下一个宏任务；</p><p>然后重复这个操作，直到任务队列里的任务执行完，这个过程就叫事件循环。</p><h2 id="二、宏任务和微任务"><a href="#二、宏任务和微任务" class="headerlink" title="二、宏任务和微任务"></a>二、宏任务和微任务</h2><p>JavaScript 的事件分两种，宏任务(macro-task)和微任务(micro-task)。</p><h3 id="1-宏任务"><a href="#1-宏任务" class="headerlink" title="1. 宏任务"></a>1. 宏任务</h3><ul><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li></ul><h3 id="2-微任务"><a href="#2-微任务" class="headerlink" title="2. 微任务"></a>2. 微任务</h3><ul><li><code>promise.then()</code> <code>promise.catch()</code> 的回调cb</li><li><code>async await</code></li><li><code>mutationObserver</code> &#x3D;&#x3D;&gt; 监听DOM的改变</li><li><code>process.nextTick()</code> &#x3D;&#x3D;&gt; Node</li></ul><p><strong>关系：</strong>微任务是包含在宏任务里面的，一个宏任务中，可以有多个微任务。</p><h3 id="3-执行顺序"><a href="#3-执行顺序" class="headerlink" title="3. 执行顺序"></a>3. 执行顺序</h3><ul><li>首先script代码块可以看做第一个宏任务，开始第一个Tick事件循环</li><li>会先执行script代码块中的同步代码</li><li>如果遇到宏任务，就放到宏任务队列中等待执行, 如果遇到微任务，放到微任务队列中</li><li>当主线程执行完同步代码的时候，首先，去微任务队列中清空当前事件循环的所有微任务（本轮事件循环Tick结束）</li><li>如果还有异步的宏任务，那么就会进行循环执行上述的操作</li></ul><h2 id="三、来点例子"><a href="#三、来点例子" class="headerlink" title="三、来点例子"></a>三、来点例子</h2><h3 id="eg1："><a href="#eg1：" class="headerlink" title="eg1："></a>eg1：</h3><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1  2  4  5  3  6</span></span><br></pre></td></tr></table></figure></div><p>执行结果为： 1  2  4  5  3  6</p><p><img lazyload src="/images/loading.svg" data-src="/../img/loop.png" alt="loop"></p><h3 id="eg2："><a href="#eg2：" class="headerlink" title="eg2："></a>eg2：</h3><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>)  </span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()      <span class="comment">// await这一行，这个async2 同步执行的; await的下面，放到微任务队列</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>) <span class="comment">// 这一行，相当于放到.then()中  微1 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">666</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>) <span class="comment">// 放到宏任务队列中 宏1 </span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)  <span class="comment">// 微任务  微2 </span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start </span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// 666</span></span><br><span class="line"><span class="comment">// promise2  (本轮tick结束)</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure></div><p>执行结果为：</p><p>![loop1](..&#x2F;img&#x2F;loop 1.png)</p><p>![loop2](..&#x2F;img&#x2F;loop 2.png)</p><p>在本轮事件循环中的微任务比下一次的事件循环中的宏任务优先级高，也就是我们要将这轮的微任务都执行完毕，才能去执行下一个宏任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件循环-Event-Loop&quot;&gt;&lt;a href=&quot;#事件循环-Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;事件循环(Event Loop)&quot;&gt;&lt;/a&gt;事件循环(Event Loop)&lt;/h1&gt;&lt;h2 id=&quot;一、什么是Event-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>防抖节流的原理</title>
    <link href="http://example.com/2022/11/14/debounce/"/>
    <id>http://example.com/2022/11/14/debounce/</id>
    <published>2022-11-14T14:34:04.000Z</published>
    <updated>2023-03-05T09:17:06.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防抖节流的原理"><a href="#防抖节流的原理" class="headerlink" title="防抖节流的原理"></a>防抖节流的原理</h1><h2 id="一、防抖（debounce）"><a href="#一、防抖（debounce）" class="headerlink" title="一、防抖（debounce）"></a>一、防抖（debounce）</h2><h3 id="1-防抖函数原理"><a href="#1-防抖函数原理" class="headerlink" title="1. 防抖函数原理"></a>1. 防抖函数原理</h3><p><strong>定义：</strong>触发高频事件后n秒内函数只会执行一次，如果在这n秒内又被触发，则重新计时。</p><p><img lazyload src="/images/loading.svg" data-src="/../img/debounce6.png" alt="debounce6"></p><p>通俗点来讲，这就相当于用手机聊天采用手写输入法时，在你一笔一画写完一个汉字后等待一段时间，这个字就会被打印在输入框，而不是写一笔画立刻就打印一笔画。也就是说，在一段时间内连续书写笔画，并不会把笔画打印出来，而是在停笔后的一段时间，完整的汉字才会被打印。</p><p>简单的定时器版本防抖函数（不会立即执行）：</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timerId;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>; <span class="comment">// 保存this指向</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>; <span class="comment">// 拿到event对象</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timerId)</span><br><span class="line">        timerId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里要特别强调一下：<strong>为什么 timerId 要定义在外边？</strong></p><p>如果放在里面，每执行函数时，就会声明一个 timerId，接着 clearTimeout 又会将这个timerId清掉，然后执行一个定时器，在下次再执行函数的时候，又会重新声明一个新的 timerId。</p><p>也就是说这个函数一调用完，就会把它给销毁，也就是垃圾回收机制，但是下面定时器的 timerId 并没有销毁。所以我们就要将它放在外边，形成一个闭包，让这个变量私有化，的存起来形成一个单独的空间，每次改变的都是它，这样就可以清除掉定时器timerId 了。</p><h3 id="2-举个例子"><a href="#2-举个例子" class="headerlink" title="2. 举个例子"></a>2. 举个例子</h3><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span>&gt;<span class="number">0</span>&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点我加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 定义变量i,存放数字</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> i = <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> addFn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 我们要让this指向box盒子，让box里的数字变化</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 在控制台打印this，方便我们观察this指向的元素是否正确</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">innerHTML</span> = i++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, s</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 声明一个定时器标记timerId</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> timerId</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 直接将function作为返回值返回</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...arg</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 每点击一次按钮，就关闭定时器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="built_in">clearTimeout</span>(timerId)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 开启定时器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            timerId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 使用call()改变this指向，不改this指向的话，这里的this就不指向box了，</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// addFn函数的this.innerHTML就不会执行</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                fn.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;, s)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// bind也是用来改变this指向的，让this指向的是显示数字的box盒子</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title function_">debounce</span>(addFn, <span class="number">1000</span>).<span class="title function_">bind</span>(box))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div><p>效果如下：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/debounce5.gif" alt="debounce5"></p><p>从以上例子中可以看出，当我在一段时间内连续点击时，数字并不会加1，在我停止点击后一段时间，数字才会加1，这就是防抖。</p><p>同时，这个简单的例子中也涉及到了很多的小细节，下面我会一一为大家讲解。</p><p><strong>2.1 return分析</strong></p><p>因为在监听事件中调用的 debounce 加了一个括号，所以它会立即执行，所以上面的 debounce 里面的代码会立即执行，当我们再点击按钮的时候，就没有效果了。</p><p>如果我们 return 一个函数，就相当于把那个函数拿到了事件监听的第二个参数里面，触发事件的时候才会执行。</p><p>也就是 return function 外面的代码，绑定 click 事件的时候，就立即执行了；return function 里面的代码，触发事件的时候执行。</p><p><img lazyload src="/images/loading.svg" data-src="/../img/debounce1.gif" alt="debounce1"></p><p><strong>2.2 this指向</strong></p><p>因为调用的 addfn 函数会在定时器里运行，且定时器里的 this 指向的是window，而函数在没有被调用之前 this 的指向是 box，因此这样就改变了 this 的指向，addFn函数的this.innerHTML就不会执行。</p><p><img lazyload src="/images/loading.svg" data-src="/../img/debounce2.png" alt="debounce2"></p><p>所以，我们需要改变 this 的指向，使其一直指向 box。</p><p><strong>对 this 指向的补充知识点：</strong></p><ul><li>箭头函数的 this 在定义的时候就确定了，指向的是上层作用域中的 this</li><li>全局作用域中 &#x2F; 普通函数中 &#x2F; 定时器里面 this 指向 window</li><li>事件注册的时候, this指向被绑定的元素</li><li>构造函数中, this 指向的是 构造函数的实例</li></ul><p><strong>2.3 改变this指向</strong></p><p>先介绍三种改变this指向的方法：call、apply、bind。</p><p><strong>call：</strong>改变this的指向；会调用函数，且立即执行；第一个参数是this指向的对象，第二个参数是参数列表。</p><p><strong>apply：</strong>改变this的指向；会调用函数，且立即执行；第一个参数是this指向的对象，第二个参数是数组。</p><p><strong>bind：</strong>改变this指向；不会立即执行，需要我们手动调用执行；有返回值，返回值是一个函数，</p><p><strong>call apply bind的区别：</strong></p><ul><li>都可以改变this指向</li><li>call接收的是参数列表，apply接收的是数组</li><li>call和apply会立即执行，bind返回函数，需要手动调用</li></ul><p><strong>2.4 传参</strong></p><p>有时我们会用到更多的参数，如果都写进去有点多，所以我们可以用剩余参数来传参。这个时候在fn.call(this,…args)里面它叫扩展运算符，也可以写成 fn.apply(this,args)。</p><h2 id="二、节流（throttle）"><a href="#二、节流（throttle）" class="headerlink" title="二、节流（throttle）"></a>二、节流（throttle）</h2><h3 id="1-节流函数原理"><a href="#1-节流函数原理" class="headerlink" title="1. 节流函数原理"></a>1. 节流函数原理</h3><p><strong>定义：</strong>n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效。</p><p><img lazyload src="/images/loading.svg" data-src="/../img/debounce4.png" alt="debounce4"></p><p>节流通俗点来讲，就是在抢优惠券的时候，无论你重复点击它多少次，只会生效一次。</p><p>时间戳版本的节流函数：（立即执行）</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled1</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> newtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        <span class="keyword">if</span> (newtime - oldtime &gt;= delay) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args)</span><br><span class="line">            oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当时间戳now与时间戳起点的时间间隔大于delay时，执行回调函数。最后将当前时间记录下来，作为下一次计时的起点。</p><h3 id="2-举个例子-1"><a href="#2-举个例子-1" class="headerlink" title="2. 举个例子"></a>2. 举个例子</h3><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span>&gt;<span class="number">0</span>&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点我加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 获取按钮和显示框</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 定义变量i,存放数字</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> i = <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> addFn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 我们要让this指向box盒子，让box里的数字变化</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 在控制台打印this，方便我们观察this指向的元素是否正确</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">innerHTML</span> = i++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, s = <span class="number">0</span></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 定义时间戳起点</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> pre = <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 鼠标一点击按钮，就记录下当前的时间戳</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 当时间戳now与时间戳起点的时间间隔大于s时，执行回调函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">if</span> (now - pre &gt;= s) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 绑定this，确保this的指向正确</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 将当前时间记录下来，作为下一次计时的起点</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                pre = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 同时使用bind()函数让this指向box</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title function_">throttle</span>(addFn, <span class="number">3000</span>).<span class="title function_">bind</span>(box))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div><p>效果如下：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/debounce3.gif" alt="debounce3"></p><p>从以上例子我们可看出，在2s内无论我点击多少次，数字都只会加1，也就是只执行一次，这就是节流。</p><p>此代码段中也涉及到了 return 的分析、this 指向和传参的问题，这里就不再重复说明了。</p><h2 id="三、区别和应用场景"><a href="#三、区别和应用场景" class="headerlink" title="三、区别和应用场景"></a>三、区别和应用场景</h2><h3 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1. 相同点"></a>1. 相同点</h3><ul><li>都可以通过使用 setTimeout 实现</li><li>目的都是，降低回调执行频率。节省计算资源</li></ul><h3 id="2-不同点"><a href="#2-不同点" class="headerlink" title="2. 不同点"></a>2. 不同点</h3><ul><li>函数防抖，在一段连续操作结束后，处理回调，利用 clearTimeout 和 setTimeout 实现。函数<br>节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。</li><li>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次。</li></ul><h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h3><p><strong>防抖：</strong>频繁触发按钮点击事件、input框搜索等。</p><p><strong>节流：</strong>浏览器窗口缩放resize事件，滚动scroll事件，mousemove事件等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;防抖节流的原理&quot;&gt;&lt;a href=&quot;#防抖节流的原理&quot; class=&quot;headerlink&quot; title=&quot;防抖节流的原理&quot;&gt;&lt;/a&gt;防抖节流的原理&lt;/h1&gt;&lt;h2 id=&quot;一、防抖（debounce）&quot;&gt;&lt;a href=&quot;#一、防抖（debounce）&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript原型，原型链</title>
    <link href="http://example.com/2022/11/04/prototype/"/>
    <id>http://example.com/2022/11/04/prototype/</id>
    <published>2022-11-04T07:37:12.000Z</published>
    <updated>2023-03-05T09:18:08.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript原型，原型链"><a href="#JavaScript原型，原型链" class="headerlink" title="JavaScript原型，原型链"></a>JavaScript原型，原型链</h1><p>原型和构造函数密切相关，了解原型之前，我们先回顾一下构造函数。</p><h2 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h2><p>像 Object 和 Array 这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。——JavaScript高级程序设计</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hobby</span>= <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sport&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1= <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jony&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">hobby</span>()</span><br><span class="line">person2.<span class="title function_">hobby</span>()</span><br></pre></td></tr></table></figure></div><p>需要注意的是，构造函数名称的首字母都是要大写的。函数体内使用this关键字，代表所要生成的对象实例。任何函数只要使用 new 操作符调用就是构造函数。</p><p>构造函数虽然有用，但是也存在着<strong>浪费内存的问题</strong>：每创建一个对象，都会在堆内存空间中新开辟一个空间来存储方法。这个问题可以通过引入原型对象来解决。</p><h2 id="二、原型"><a href="#二、原型" class="headerlink" title="二、原型"></a>二、原型</h2><p><strong>原型</strong>就是一个对象，也叫原型对象。</p><h3 id="1-理解原型"><a href="#1-理解原型" class="headerlink" title="1. 理解原型"></a>1. 理解原型</h3><ul><li>每个函数都会创建一个 prototype 属性，属性值是一个普通对象。</li></ul><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="title class_">Person</span>)</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/../img/prototype.png" alt="prototype"></p><ul><li>原型上默认有一个叫做constructor的属性，指向这个构造函数本身。</li></ul><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><ul><li>使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。</li></ul><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">7</span>;</span><br><span class="line"><span class="comment">// 公共的方法写到原型对象上  节约了内存</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hobby</span>= <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sport&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">const</span> res = person1.<span class="property">name</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)  <span class="comment">// &quot;Mike&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">const</span> res = person2.<span class="property">name</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)  <span class="comment">// &quot;Mike&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">hobby</span>== person2.<span class="property">hobby</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><h3 id="2-proto-隐式原型"><a href="#2-proto-隐式原型" class="headerlink" title="2. __proto__隐式原型"></a>2. __<strong>proto</strong>__隐式原型</h3><ul><li>所有对象，都有一个__proto__属性，指向原型对象。</li><li>实例通过__proto__访问原型对象。</li><li>对象的隐式原型指向构造函数的显示原型</li></ul><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)   <span class="comment">//true</span></span><br></pre></td></tr></table></figure></div><p><strong>proto 表示了实例和原型之间的一个关系，相当于就是一个桥梁，实例通过它访问原型。</strong></p><h2 id="三、构造函数、原型、实例的关系"><a href="#三、构造函数、原型、实例的关系" class="headerlink" title="三、构造函数、原型、实例的关系"></a>三、构造函数、原型、实例的关系</h2><ol><li>构造函数.prototype  ——&gt;  原型对象</li><li>原型对象.constructor  ——&gt;  构造函数</li><li>实例对象.<strong>proto</strong>  ——&gt;  原型对象</li><li>构造函数 new , 创建出实例对象</li></ol><p><img lazyload src="/images/loading.svg" data-src="/../img/prototype1.png" alt="prototype1"></p><p><strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有直接联系。</strong></p><h2 id="四、原型的五条规则"><a href="#四、原型的五条规则" class="headerlink" title="四、原型的五条规则"></a>四、<strong>原型的五条规则</strong></h2><ol><li>所有的引用类型（对象 数组 函数），都具有对象的特征，可以自由扩展属性。</li><li>每一个对象都有一个 <strong>proto</strong> 属性，这个属性是一个对象。</li><li>所有的函数都有一个 prototype 属性，这个属性也是一个对象。</li><li>所有对象的 <strong>proto</strong> 属性值，都指向它的构造函数 prototype 属性值。</li><li>实例化对象想要获取的属性值如果构造函数没有，它会向构造函数的原型中寻找，如果原型也没有，则会向原型的 <strong>proto</strong> 中寻找，直到拿到或没有该属性值。</li></ol><h2 id="五、原型链"><a href="#五、原型链" class="headerlink" title="五、原型链"></a>五、原型链</h2><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br></pre></td></tr></table></figure></div><ol><li>对象的隐式原型指向构造函数的显示原型。</li></ol><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><ol><li>所有的对象都有一个 <strong>proto</strong> ，属性值也是一个对象，Person.prototype 也是一个对象，所以，它也有 <strong>proto</strong> 属性，属性值也是对象。原型上默认有一个 constructor 属性，指回的构造函数，所以 Person.prototype 的构造函数是 Object。</li></ol><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>)  <span class="comment">// __proto__ 访问到原型</span></span><br><span class="line"><span class="comment">// Person.prototype 这个原型对象 是Object这个构造函数创建的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><ol><li>Object 是一个构造函数，Object.prototype 得到的也是一个原型，所以 Object.prototype 这个原型上默认有一个constructor属性，指向构造函数本身。</li></ol><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Object</span>  <span class="comment">// Object.prototype指向构造函数本身</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><ol><li>Object.prototype 也是一个原型对象，所以它也有一个 <strong>proto</strong> 属性。</li></ol><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常的原型链终止到Object.prototype, 也就是 Object.prototype.__proto__ === null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="literal">null</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><p>根据以上结论，我们用一张图来更加清晰的理解原型链：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/prototype2.png" alt="prototype2"></p><p><strong>简单概况一下：</strong></p><p>每个对象通过 <strong>proto</strong> 属性都能访问到它的原型对象，原型对象也有它的原型对象，当访问一个对象属性或方法的时候，先在自身中寻找，如果没有，就会沿着 <strong>proto</strong> 这条链向上查找，直到最顶层 Object.prototype 为止，最后 Object.prototype.proto &#x3D;&#x3D;&#x3D; null。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript原型，原型链&quot;&gt;&lt;a href=&quot;#JavaScript原型，原型链&quot; class=&quot;headerlink&quot; title=&quot;JavaScript原型，原型链&quot;&gt;&lt;/a&gt;JavaScript原型，原型链&lt;/h1&gt;&lt;p&gt;原型和构造函数密切相关，了解</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>详解闭包</title>
    <link href="http://example.com/2022/10/29/closure/"/>
    <id>http://example.com/2022/10/29/closure/</id>
    <published>2022-10-29T09:26:27.000Z</published>
    <updated>2023-03-05T09:14:04.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解闭包"><a href="#详解闭包" class="headerlink" title="详解闭包"></a>详解闭包</h1><h2 id="一、简单介绍"><a href="#一、简单介绍" class="headerlink" title="一、简单介绍"></a>一、简单介绍</h2><p>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p><p>通俗来说，<strong>闭包 &#x3D; 内层函数 + 外层函数的变量</strong></p><h2 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h2><p>想要理解闭包，首先必须理解JS的作用域，作用域分为<strong>全局作用域</strong>和<strong>局部作用域。ES6新增了块级作用域。</strong></p><h3 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1. 全局作用域"></a><strong>1. 全局作用域</strong></h3><p>全局作用域中声明的变量，在代码的任何地方都可以访问，其生命周期伴随着页面的生命周期。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处可以打印出结果，结果为10</span></span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNum</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 因为没有声明变量，所以num变成了window的属性</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>()</span><br><span class="line"><span class="comment">// 可以获取到num的值，打印结果为10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br></pre></td></tr></table></figure></div><h3 id="2-局部作用域"><a href="#2-局部作用域" class="headerlink" title="2. 局部作用域"></a><strong>2. 局部作用域</strong></h3><p><strong>2.1 函数作用域</strong></p><p>在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无法访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br></pre></td></tr></table></figure></div><p><strong>2.2 块级作用域</strong></p><p>{ } 包裹起来的代码称为代码块, 使用 let 或 const 声明的变量, 在 { } 会产生块级作用域</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 只有let、const会产生块级作用域，var声明不会产生块级作用域</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getNum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 块级作用域的外部不能访问内部的变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 可以访问</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无法访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 不同代码块之间的变量无法相互访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125; <span class="comment">// 0 1 2 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125; <span class="comment">// 0 1 2 3 4</span></span><br></pre></td></tr></table></figure></div><p>那么我们怎样才能从外部读取局部作用域呢？这就涉及到了<strong>作用域链</strong>这个概念。</p><h3 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3. 作用域链"></a>3. 作用域链</h3><p>在很多情况下，我们需要得到函数内的局部变量，因为函数是可以嵌套函数的，每个函数都有一个局部作用域，这样也会形成作用域的嵌套。所以我们只需要<strong>在函数的内部，再定义一个函数。</strong></p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 局部作用域</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 局部作用域</span></span><br><span class="line"><span class="comment">// num = 20</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn2</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>() <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></div><p>因为 fn2 嵌套在 fn1 中，这时 fn1 内部的所有局部变量，对 fn2 都是可见的。反之，fn2 内部的局部变量，对 fn1 就是不可见的。</p><p>所以，作用域的查找<strong>查找规则</strong>是：子对象会往上层作用域中查找变量，直到全局作用域。它的本质就是<strong>底层变量的查找机制。</strong></p><h2 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h2><p>上述代码中的 fn2 函数和外层函数变量的集合就是闭包。</p><h3 id="1-闭包的简单写法"><a href="#1-闭包的简单写法" class="headerlink" title="1. 闭包的简单写法"></a>1. 闭包的简单写法</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fun = <span class="title function_">outer</span>()</span><br><span class="line"><span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure></div><p>外层函数就相当于把这个整体包裹起来了，所以叫闭包。</p><h3 id="2-闭包的应用"><a href="#2-闭包的应用" class="headerlink" title="2. 闭包的应用"></a>2. 闭包的应用</h3><ul><li>保护函数内的变量安全。以最开始的例子为例，函数 outer 中的 num 只有函数 fn才能访问，而无法通过其他途径访问到，因此保护了 num 的安全性。</li><li>在内存中维持一个变量。</li></ul><p>eg：for循环中的定时器</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    ;(<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>使用闭包将 i 长期存储在内存中。</p><!-- ![closure1](./img/closure1.png) --><p><img lazyload src="/images/loading.svg" data-src="/../img/closure1.png" alt="closure1"></p><p>闭包可能会引起的问题：<strong>内存泄漏。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;详解闭包&quot;&gt;&lt;a href=&quot;#详解闭包&quot; class=&quot;headerlink&quot; title=&quot;详解闭包&quot;&gt;&lt;/a&gt;详解闭包&lt;/h1&gt;&lt;h2 id=&quot;一、简单介绍&quot;&gt;&lt;a href=&quot;#一、简单介绍&quot; class=&quot;headerlink&quot; title=&quot;一、简单介</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>本地存储</title>
    <link href="http://example.com/2022/10/25/storage/"/>
    <id>http://example.com/2022/10/25/storage/</id>
    <published>2022-10-25T12:57:04.000Z</published>
    <updated>2023-03-05T09:18:25.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h1><p><strong>一、localStorage</strong></p><p><strong>1. 介绍localStorage</strong></p><p>localStorage 是 HTML5 的新方法，适用于大量数据存储需求，存储大小为5M。其生命周期是永久生效，除非被清理，否则一直存在。其数据可以多窗口共享。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 储存数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(key,value)</span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key)</span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(key)</span><br><span class="line"><span class="comment">//清空所有数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure></div><p><strong>2. localStorage实例</strong></p><p>了解了它的基本语法后，下面将举一个例子让大家更加深入的理解它的用法。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;&quot;</span> id=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;get&quot;</span>&gt;</span>获取数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;set&quot;</span>&gt;</span>存储数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;remove&quot;</span>&gt;</span>删除数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 获取元素  </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">const</span> get = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.get&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">const</span> set = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.set&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">const</span> ipt = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">const</span> remove = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.remove&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">// 存储数据  点击set存input的value值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       set.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;uname&#x27;</span>, ipt.<span class="property">value</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">// 获取数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       get.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 控制台打印为了可以看到获取数据事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;uname&#x27;</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">// 删除数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       remove.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;uname&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div><p>实现效果如下：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/storage3.gif" alt="storage3"></p><p><strong>3. localStorage特点</strong></p><p>存储在 localStorage 中的数据会保留到通过 JavaScript 删除或者用户清除浏览器缓存。localStorage 数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览器而丢失。</p><p><strong>二、sessionStorage</strong></p><p><strong>1. 介绍sessionStorage</strong></p><p>sessionStorage 是会话存储，和 localStorage 使用操作基本类似，唯一不同的是生命周期，sessionStorage 的生命周期是关闭当前标签页，即会话结束，其数据在同一个窗口共享。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 储存数据</span></span><br><span class="line">sessionStorage.<span class="title function_">setItem</span>(key,value)</span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">sessionStorage.<span class="title function_">getItem</span>(key)</span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">sessionStorage.<span class="title function_">removeItem</span>(key)</span><br><span class="line"><span class="comment">//清空所有数据</span></span><br><span class="line">sessionStorage.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure></div><ol start="2"><li>sessionStorage 应用场景</li></ol><p>敏感账号一次性登录。</p><p><strong>三、存储复杂数据类型</strong></p><p><strong>1. 简介</strong></p><p>本地只能存储字符串，无法存储复杂数据类型，所以需要先把复杂数据类型转换为JSON字符串，后再存储到本地。</p><p><strong>2. 语法：JSON.stringify(复杂数据类型)</strong></p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">userId</span>: <span class="string">&#x27;01&#x27;</span>,</span><br><span class="line">    <span class="attr">uname</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 存数据 需要先转换为JSON格式的字符串</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;message&#x27;</span>, res)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 取数据 把JSON字符串转换为对象</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;message&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br></pre></td></tr></table></figure></div><p>存数据：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/storage4.png" alt="storage4"></p><p>取数据：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/storage1.png" alt="storage1"></p><p><strong>3. 语法：JSON.parse(JSON字符串)</strong></p><p>因为本地存储里面取出来的是字符串，不是对象，无法直接使用，所以把取出来的字符串转换为对象。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;message&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/../img/storage2.png" alt="storage2"></p><p>综上，JSON.stringify()是将对象转换为JSON格式的字符串，JSON.parse()是将JSON格式的字符串转为对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本地存储&quot;&gt;&lt;a href=&quot;#本地存储&quot; class=&quot;headerlink&quot; title=&quot;本地存储&quot;&gt;&lt;/a&gt;本地存储&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;一、localStorage&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 介绍localStora</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>事件委托</title>
    <link href="http://example.com/2022/10/24/event/"/>
    <id>http://example.com/2022/10/24/event/</id>
    <published>2022-10-23T17:03:56.000Z</published>
    <updated>2023-03-05T09:17:39.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p><strong>一、什么是事件委托</strong></p><p>提到事件委托，我们必须先了解事件流中的事件捕获和事件冒泡。</p><p><strong>事件捕获</strong>就是从DOM的根元素开始去执行对应的事件，执行过程是从外到里。</p><p><strong>事件冒泡</strong>就是从文档树中最深的节点开始触发，然后向上传播至没有那么具体的文档，执行过程是从里到外。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   &lt;ul&gt;</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>first child<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;li&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">const</span> body = <span class="variable language_">document</span>.<span class="property">body</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       li.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是子元素&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是父元素&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       body.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是body&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是document&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div><p>效果如下：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/weituo.gif" alt="weituo"></p><p>当我点击子元素的时候，就触发了事件冒泡机制，从 li 开始触发到 ul 再到 body 最后到 document</p><p>而<strong>事件委托</strong>就是利用<strong>事件冒泡</strong>，把原本要绑定在子元素的响应事件委托给父元素，通过父元素监听子元素。</p><p><strong>二、使用场景</strong></p><p>当我们要给n个按钮添加点击事件时，最笨的方法就是给每个按钮都添加，此方法耗时且麻烦。但是如果委托给父元素，让父元素担当事件监听的职务，则通过事件冒泡就可以获取到所有子元素。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>first child<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>secend child<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>third child<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>forth child<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>fifth child<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">// 点击每个小li 被点击的li消失</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">// 1. 获得父元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 2. 利用事件委托，将点击事件委托给父元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="comment">// e.target: 判断点的是哪一个元素（标签）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="comment">// tagName: 标签名字</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 3. 找到触发的元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">tagName</span> === <span class="string">&#x27;LI&#x27;</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div><p>效果如下：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/child.gif" alt="child"></p><p>其中，e.target 是事件源，获取 e.target 以查看事件实际发生的位置并进行处理；tagName 是标签名字，注意必须得大写。</p><p><strong>三、优点</strong></p><ol><li>减少事件注册的次数，节省内存占用，提高程序的性能</li><li>新增子对象时也无需再次对其绑定</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件委托&quot;&gt;&lt;a href=&quot;#事件委托&quot; class=&quot;headerlink&quot; title=&quot;事件委托&quot;&gt;&lt;/a&gt;事件委托&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;一、什么是事件委托&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提到事件委托，我们必须先了解事件流中的事件捕获和事件冒泡</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>打印99乘法表</title>
    <link href="http://example.com/2022/10/21/print/"/>
    <id>http://example.com/2022/10/21/print/</id>
    <published>2022-10-21T14:54:04.000Z</published>
    <updated>2023-03-05T09:17:50.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打印99乘法表"><a href="#打印99乘法表" class="headerlink" title="打印99乘法表"></a>打印99乘法表</h1><p>在学习打印乘法表之前，我们可以通过两个案例去理解它的实现原理。</p><p><strong>一、打印一个矩形</strong></p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> row = +<span class="title function_">prompt</span>(<span class="string">&#x27;请输入行数:&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> col = +<span class="title function_">prompt</span>(<span class="string">&#x27;请输入列数:&#x27;</span>)</span><br><span class="line"><span class="comment">// 1. 外层循环打印行数</span></span><br><span class="line"><span class="comment">// row等于几则输出几行</span></span><br><span class="line"><span class="comment">// 加上换行操作，三个笑脸会转换成垂直排列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line"><span class="comment">// 2. 里层循环打印n个笑脸</span></span><br><span class="line"><span class="comment">// col等于几则输出几列，也就是每行输出几个笑脸</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= col; j++) &#123;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;☺&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 3. 进行换行显示</span></span><br><span class="line">   <span class="comment">// 让外层循环打印的笑脸垂直排列</span></span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当 row &#x3D; 3，col &#x3D; 4 时，打印的结果如下：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/juxing.png" alt="juxing"></p><p><strong>二、打印一个直角三角形</strong></p><p>与打印矩形唯一不同的是，打印直角三角形的方法中，里层循环的终止条件略有不同。</p><p>通过观察可以发现，直角三角形中，每一行的笑脸个数等于它所在的行数，例如：第一行有一个笑脸，第二行有两个笑脸…以此类推，所以，它的终止条件从小于等于输入的列数变为了小于等于行数。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> row = +<span class="title function_">prompt</span>(<span class="string">&#x27;请输入行数:&#x27;</span>)</span><br><span class="line"><span class="comment">// 1. 外层循环控制行数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line">    <span class="comment">// 2. 里层循环控制列数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;☺&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 3. 进行换行显示</span></span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当 row &#x3D; 5 时，打印的结果如下：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/sanjiao.png" alt="sanjiao"></p><p>原理：无论是打印矩形还是直角三角形，都是利用了for的循环嵌套：外层循环控制打印行，内层循环控制每行打印几列。</p><p><strong>三、打印99乘法表</strong></p><p>通过以上两个练习，我们就可以很轻松的打印出一个99乘法表，它和直角三角形的形状一模一样，所以我们可以利用打印直角三角形的方法来打印99乘法表。</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 外层循环控制行数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 2. 里层循环控制列数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">  <span class="comment">// 输出对象的格式 </span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`&lt;span&gt;<span class="subst">$&#123;j&#125;</span> X <span class="subst">$&#123;i&#125;</span> = <span class="subst">$&#123;i * j&#125;</span>&lt;/span&gt;`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 换行</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印的结果如下：</p><p><img lazyload src="/images/loading.svg" data-src="/../img/chengfabiao.png" alt="chengfabiao"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;打印99乘法表&quot;&gt;&lt;a href=&quot;#打印99乘法表&quot; class=&quot;headerlink&quot; title=&quot;打印99乘法表&quot;&gt;&lt;/a&gt;打印99乘法表&lt;/h1&gt;&lt;p&gt;在学习打印乘法表之前，我们可以通过两个案例去理解它的实现原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、打</summary>
      
    
    
    
    
  </entry>
  
</feed>
